React

创建项目
	npx create-react-app react-app    npm cache clean --force
			npm install -g create-react-app		create-react-app demo-app
	cd my-app
	npm start

JSX
	1.在 JSX 中嵌入表达式
		在大括号中使用变量，在 JSX 语法中，你可以在大括号内放置任何有效的 JavaScript 表达式
	2.JSX 也是一个表达式
		可以在 if 语句和 for 循环的代码块中使用 JSX，将 JSX 赋值给变量，把 JSX 当作参数传入，以及从函数中返回 JSX：
	3.JSX 特定属性
		可以通过使用引号，来将属性值指定为字符串字面量：
			const element = <div tabIndex="0"></div>;
		也可以使用大括号，来在属性值中插入一个 JavaScript 表达式：
			const element = <img src={user.avatarUrl}></img>;
		对于同一属性不能同时使用这两种符号。
	4.使用 JSX 指定子元素
	5.JSX 防止注入攻击
		React DOM 在渲染所有输入内容之前，默认会进行转义。
	6.JSX 表示对象
		Babel 会把 JSX 转译成一个名为 React.createElement() 函数调用。
		
元素渲染
	ReactDOM.render(element, document.getElementById('root'));

组件&props
	函数组件
		function Welcome(props) {
			return <h1>Hello, {props.name}</h1>;
		}

		const element = <Welcome name="Sara" />;
		ReactDOM.render(
			element,
			document.getElementById('root')
		);
	class组件
		通过以下五步将 Clock 的函数组件转成 class 组件：
			创建一个同名的 ES6 class，并且继承于 React.Component。
			添加一个空的 render() 方法。
			将函数体移动到 render() 方法之中。
			在 render() 方法中使用 this.props 替换 props。
			删除剩余的空函数声明。
		每次组件更新时 render 方法都会被调用，但只要在相同的 DOM 节点中渲染 <Clock /> ，就仅有一个 Clock 组件的 class 实例被创建使用。
		这就使得我们可以使用如 state 或生命周期方法等很多其他特性。
		
state&生命周期
	State 与 props 类似，但是 state 是私有的，并且完全受控于当前组件。
	
	将生命周期方法添加到 Class 中
		componentDidMount() {
			组件已经被渲染到 DOM 中后运行
		}
		componentWillUnmount() {

		}
	正确地使用 State
		1.不要直接修改 State，this.state.comment = 'Hello';	而是this.setState({comment: 'Hello'});
			构造函数是唯一可以给 this.state 赋值的地方：
		2.State 的更新可能是异步的
			出于性能考虑，React 可能会把多个 setState() 调用合并成一个调用。
			因为 this.props 和 this.state 可能会异步更新，所以你不要依赖他们的值来更新下一个状态。
			要解决这个问题，可以让 setState() 接收一个函数而不是一个对象。这个函数用上一个 state 作为第一个参数，将此次更新被应用时的 props 做为第二个参数：
				this.setState((state, props) => ({
				  counter: state.counter + props.increment
				}));
		3.State 的更新会被合并
			 this.setState({comments}) 完整保留了 this.state.posts， 但是完全替换了 this.state.comments。
			 
	数据是向下流动的
		不管是父组件或是子组件都无法知道某个组件是有状态的还是无状态的，并且它们也并不关心它是函数组件还是 class 组件。
		
事件处理
	React 元素的事件处理和 DOM 元素的很相似，但是有一点语法上的不同:
		React 事件的命名采用小驼峰式（camelCase），而不是纯小写。
		使用 JSX 语法时你需要传入一个函数作为事件处理函数，而不是一个字符串。
		
		<button onClick={activateLasers}>
		  Activate Lasers
		</button>
	在 React 中另一个不同点是你不能通过返回 false 的方式阻止默认行为。你必须显式的使用 preventDefault 。
		function ActionLink() {
		  function handleClick(e) {
			e.preventDefault();
			console.log('The link was clicked.');
		  }

		  return (
			<a href="#" onClick={handleClick}>
			  Click me
			</a>
		  );
		}
		
条件渲染
	1.if语句
	2.与运算符 &&
		在 JavaScript 中，true && expression 总是会返回 expression, 而 false && expression 总是会返回 false。
	3.三目运算符
		condition ? true : false
	4.阻止组件渲染
		让 render 方法直接返回 null，而不进行任何渲染。
		在组件的 render 方法中返回 null 并不会影响组件的生命周期。例如，上面这个示例中，componentDidUpdate 依然会被调用。	
			
列表 & Key
	const numbers = [1, 2, 3, 4, 5];
	const doubled = numbers.map((number) => number * 2);
	key 帮助 React 识别哪些元素改变了，比如被添加或删除。因此你应当给数组中的每一个元素赋予一个确定的标识。
	一个元素的 key 最好是这个元素在列表中拥有的一个独一无二的字符串。通常，我们使用数据中的 id 来作为元素的 key：
	当元素没有确定 id 的时候，万不得已你可以使用元素索引 index 作为 key：
	如果列表项目的顺序可能会变化，我们不建议使用索引来用作 key 值，因为这样做会导致性能变差，还可能引起组件状态的问题。
	
	用 key 提取组件
	key 只是在兄弟节点之间必须唯一
		数组元素中使用的 key 在其兄弟节点之间应该是独一无二的。然而，它们不需要是全局唯一的。当我们生成两个不同的数组时，我们可以使用相同的 key 值：
		key 会传递信息给 React ，但不会传递给你的组件。如果你的组件中需要使用 key 属性的值，请用其他属性名显式传递这个值
	
表单：
	受控组件
		我们可以把两者结合起来，使 React 的 state 成为“唯一数据源”。渲染表单的 React 组件还控制着用户输入过程中表单发生的操作。被 React 以这种方式控制取值的表单输入元素就叫做“受控组件”。	
			
		由于在表单元素上设置了 value 属性，因此显示的值将始终为 this.state.value，这使得 React 的 state 成为唯一数据源。
		由于 handlechange 在每次按键时都会执行并更新 React 的 state，因此显示的值将随着用户输入而更新。	
			
		对于受控组件来说，每个 state 突变都有一个相关的处理函数。这使得修改或验证用户输入变得简单。例如，如果我们要强制要求所有名称都用大写字母书写，我们可以将 handlechange 改写为：	
			
状态提升：
	多个组件需要反映相同的变化数据，这时我们建议将共享状态提升到最近的共同父组件中去。
	
组合 vs 继承	
	包含关系
		1.使用一个特殊的 children prop 来将他们的子组件传递到渲染结果中
		2.可以不使用 children，而是自行约定：将所需内容传入 props，并使用相应的 prop。
	
	<Contacts /> 和 <Chat /> 之类的 React 元素本质就是对象（object），所以你可以把它们当作 props，像其他数据一样传递。
	
	特例关系
		“特殊”组件可以通过 props 定制并渲染“一般”组件：
	
React 哲学	
	
Context
	const MyContext = React.createContext(defaultValue);
		当 React 渲染一个订阅了这个 Context 对象的组件，这个组件会从组件树中离自身最近的那个匹配的 Provider 中读取到当前的 context 值。
		只有当组件所处的树中没有匹配到 Provider 时，其 defaultValue 参数才会生效。
	Context.Provider
		<MyContext.Provider value={/* 某个值 */}>
	Class.contextType
		使用 this.context 来消费最近 Context 上的那个值。
	Context.Consumer
		<MyContext.Consumer>
		  {value => /* 基于 context 值进行渲染*/}
		</MyContext.Consumer>
	Context.displayName		
	
	
全局变量存储：
	如果只是只读变量，可以直接js定义const，然后export即可
	
	如果是读写变量，尝试过：
		1.state，这个存放于父组件中，然后传递给子组件的props
			子组件不能update数据
		2.context 
			问题：
				子组件import父组件失败
				如果存放于子组件，别的子组件会import失败，因为还未初始化
		3.redux
			值修改后，其他子组件获取到的值还没更新
		4.window.变量
			也是获取到旧值
		5.cookies
			npm install react-cookies --save   # react-cookie不管用，用法麻烦
			
UI库
	
			
高阶组件HOC
	高阶组件是参数为组件，返回值为新组件的函数。
	组件是将 props 转换为 UI，而高阶组件是将组件转换为另一个组件。
	
	请注意，HOC 不会修改传入的组件，也不会使用继承来复制其行为。相反，HOC 通过将组件包装在容器组件中来组成新组件。HOC 是纯函数，没有副作用。
	
	HOC 不应该修改传入组件，而应该使用组合的方式，通过将组件包装在容器组件中实现功能：
	
	HOC 与容器组件模式之间有相似之处。可以将 HOC 视为参数化容器组件。
	
生命周期	
	挂载：
		constructor -> getDerivedStateFromProps -> render -> componentDidMount
	更新：
		getDerivedStateFromProps -> shouldComponentUpdate -> render -> getSnapshotBeforeUpdate -> componentDidUpdate
	卸载：
		componentWillUnmount
		
关于与.net core api请求post返回400 parse error的问题
	'"'+JSON.stringify({'value':'alex'})+'"'
	
部署：
	npm run build
	1.关于静态文件path：
		设置package.json文件为homepage:'.'
	2.关于blowsrouter
	
base64防乱码：
	1.Node.js 环境的Buffer
		new Buffer(str).toString('base64');
		new Buffer(str, 'base64').toString();
	2.window 对象自带的方法 atob 和 btoa (a for ascii, b for base64)
		不能直接作用于 Unicode 字符串
		window.btoa(unescape(encodeURIComponent(str)))
		decodeURIComponent(escape(window.atob(str)));
	3.第三方 Base64 库：
		npm install --save js-base64
		import { Base64 } from 'js-base64';
		Base64.encode('小飼弾')
		Base64.decode('5bCP6aO85by-')
		